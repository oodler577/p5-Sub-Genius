#!/usr/bin/env perl

use strict;
use warnings;
use Sub::Genius::Util ();
use Getopt::Long      ();

my $VERSION = 1.0;

use constant {
    EXIT_SUCCESS => 0,
    EXIT_ERROR   => 1,
};

require Data::Dumper;

# maybe switch to App::Cmd later for sub commands,
# but it's options processing is super tard
my $subcommand = shift @ARGV;

my $subcommands = {
    help  => \&run_helf,
    init  => \&run_init,
    cache => \&run_cache,
};

my $usages = {
    help  => \&usage_helf,
    init  => \&usage_init,
    cache => \&usage_cache,
};

# enforce subcommand
if ( not $subcommand or not exists $subcommands->{$subcommand} ) {
    warn qq{\n(fatal) stubby requires valid subcommand ...\n\n};
    print_usage($usages);
    exit EXIT_ERROR;
}

exit $subcommands->{$subcommand}->( \@ARGV );

sub print_usage {
    my $usages = shift;
    print qq{All commands:\n};

    # force "help" to be first
    foreach my $usage ( ( qw/help/, grep { !m/help/ } sort keys %$usages ) ) {
        my $use = $usages->{$usage}->();
        print qq{'$usage'\n};
        print qq{\t$use\n};
    }
    print qq{\n};
}

sub usage_helf {
    return qq{stubby help};
}

sub usage_init {
    return qq{stubby init [-r|--run [once|any|all|nodeps] -s|--subroutines "sub1 sub2 sub3 ..." > my-script.pl};
}

sub usage_cache {
    return qq{stubby cache [-d path/to/cachedir [-f path/to/preplan.dat] | [-p|--preplan "p&r&e&plan"]};
}

sub run_helf {
    my $has_perldoc = system(qw/which perdoc/);
    if ( $has_perldoc > EXIT_SUCCESS ) {
        print qq{(fatal) 'perldoc' utility required, please install & resubmit your request...\n};
        return $has_perldoc;
    }
    return system( qw/perldoc/, $0 );
}

sub run_init {
    my $argv = shift;
    my %opts = ( R => q{once} );                    # default is 'once', as in C<Sub::Genius::run_once>
    my $gol  = Getopt::Long::GetOptionsFromArray(
        $argv,
        \%opts,                # container for all processed options
        q/p|preplan=s/,        # define PRE (currently for -x nodeps, only)
        q/s|subroutines=s/,    # specify name of subroutines; NOT a PRE!
        q/x|run=s/,            # specify invocation method: once, any, all, once
    );

    # no %opts checking here, relying on exceptions from Sub::Genius::Util
    if ( grep { /$opts{x}/ } (qw/once any all/) ) {
        print Sub::Genius::Util->subs2perl( q{subs} => [ split( /[\s&|,]/, $opts{s} ) ], q{with-run} => $opts{x} );
    }
    elsif ( grep { /$opts{x}/ } (qw/nodeps/) ) {
        print Sub::Genius::Util->plan2nodeps( preplan => $opts{p} );
    }
    return EXIT_SUCCESS;
}

sub run_cache {
    my $argv = shift;
    my %opts = ();
    my $gol  = Getopt::Long::GetOptionsFromArray(
        $argv,
        \%opts,           # container for all processed options
        q/d|cachedir=s/,  # specify cachedir, defaults to Sub:Genius' default
        q/f|file=s/,      # specify file containing PRE
        q/o=s/,           # specify Storable file for DFA being cached
        q/p|preplan=s/,   # define PRE (required if -f is not specified
    );

    my $cachefile = Sub::Genius::Util->precache( preplan => $opts{p}, cacheddir => $opts{d}, file => $opts{f} );
    print qq{$cachefile\n};
    return EXIT_SUCCESS;
}

exit;
__END__

=head1 NAME

stubby - commandline tool for dumping stub Perl programs sequentialized using L<Sub::Genius>.

I<EXPERIMENTAL>, subject to wild swings in options and behaviors.

=head1 SYNOPSIS

    $ stubby init [--run [once|any|all|nodeps]] [-s|--subroutines = "sub1 sub2 sub3 ..."] [-p|--preplan = "an & actual (PRE) ..."] 

    $ stubby precache [-f preplan.dat|--preplan = 'PRE...'] [-d path/to/cachedir]  # NOT YET IMPLEMENTED

Example,

with C<use Sub::Genius ();>:
 
    $ stubby init --run once   -s "init spawn threadsA criticalsectA threadsB criticalsectB combine" > ./spawn-combine.pl

without C<Sub::Genius>:

    $ stubby init --run nodeps -p "init ( threadA & threadB & threadC ) criticalSection ( threadA & threadB & threadC ) finalize" > ./spawn-combine.pl

cache only (for precompiling DFAs) B<NOT YET IMPLEMENTED>

    $ stubby precache -p "init ( threadA & threadB & threadC ) criticalSection ( threadA & threadB & threadC ) finalize" # NOT YET IMPLEMENTED

    $ stubby precache -f ./my-preplan.dat -d put/in/here # NOT YET IMPLEMENTED

=head1 DESCRIPTION

Commandline tool for generating boilerplate for use with L<Sub::Genius>.

Leverages the caching effects of L<Sub::Genius> (see that POD for more information).

=head2 General Development Workflow

Most will want to use this to start their Perl script or module, the workflow over
the lifetime of the program might look like this:

=over 4

=item * Dump program using C<stubby>.

=item * Annotate PRE (C<$pre> in generated code) to achieve concurrent semantics (see L<Sub::Genius> for more info).

=item * Implement subroutine bodies that exist, albeit empty of anything meaningful.

=item * C<...>

=item * Profit!

=item * Maintain as any other code in your arsenal.

=back

=head1 OPTIONS

=over 4

=item C<init>

Subcommand, currently only one supported.

=item C<-R|--run>

Choose invocation method to use in the code. The default is C<once>.

Options include:

C<once> - generates code that invokes C<Sub::Genius::run_once>; requires C<-s|--subroutine>

C<any>  - generates code that invokes C<Sub::Genius::run_any>; requires C<-s|--subroutine>

C<all>  - generates code that invokes C<Sub::Genius::run_once>, in a C<do { ... } while ()> loop; requires C<-s|--subroutine>

C<nodeps> - generates code that is free of any dependencies, including C<Sub::Genius>; requires C<-p|--preplan>

=item C<-s|--subroutines>

Specify a space delimited list of subroutine names to generate stubs and a unannotated PRE.

Command fails if provided any values other than words and spaces (to prevent misinterpretation of PRE - may change).

=item C<-p|--preplan>

An actual PRE, used with C<--run nodeps>.

=back

=head1 SEE ALSO

L<Sub::Genius>

=head1 BUGS

I<Probably>

=head1 COPYRIGHT AND LICENSE

perl5

=head1 AUTHOR

OODLER 577 E<lt>oodler@cpan.orgE<gt>
